~~~python
class Solution:
    def sub_sort(self,nums,low,high):
        # 利用 range 取不到 high 的特性，pilot 设定为 high 位置的 value
        pilot = nums[high]
        # 从 low 位置开始，向后慢慢寻找小于 value 的元素
        i = low
        for j in range(low,high):
            # value 大于其中的元素了
            if pilot > nums[j]: 
                nums[i], nums[j] = nums[j], nums[i]
                # i 比 j 率先变化
                i += 1
        # 此时的 i 位置的数，一定大于value，最终的交换
        nums[i], nums[high] = nums[high] ,nums[i]
        # 返回排序好的 i 位置
        return i


    def quicksort(self,nums,left,right):
        if left > right:return
        pi = self.sub_sort(nums,left,right)
        self.quicksort(nums,left,pi-1)
        self.quicksort(nums,pi+1,right)

    def sortArray(self, nums: List[int]) -> List[int]:
        self.quicksort(nums,0,len(nums)-1)
        return nums

~~~

## 快速排序

~~~python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        def foo(left,right):
            if left>right: return 
            # init
            # 给left 和right做备份，不可动
            i = left
            j = right
            tmp = nums[left]
            # sort()
            while i != j:
                # i 必须时刻小于j
                while nums[j] >= tmp and i < j: # 不要忘记等于
                    j -= 1 #
                while nums[i] <= tmp and i < j:
                    i += 1
                # 确保小的在左边，大的在右边
                nums[i],nums[j] = nums[j],nums[i]
            # reset，把left移动到i位置，这样左边就是小，右边就是大了
            nums[left],nums[i] = nums[i],nums[left]
            foo(left,i-1)
            foo(i+1,right)
        
        foo(0,len(nums)-1)
        return nums
~~~


