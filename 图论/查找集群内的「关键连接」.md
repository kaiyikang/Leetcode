## B站大佬的参考第一版

~~~python
class Solution:
    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:
        # 建图
        graph = collections.defaultdict(list)
        for conn in connections:
            graph[conn[0]].append(conn[1])
            graph[conn[1]].append(conn[0])

        # 建id
        ids = [-1] * n

        # 建返回
        res = []

        # 定义深度优先
        def dfs(cur_node, cur_id, par):
            # 在探索之前，给你个id
            ids[cur_node] = cur_id
            
            # 探索相邻节点
            for next_node in graph[cur_node]: # 寻找相邻节点
                if next_node == par: # 忽略自己
                    continue
                elif ids[next_node] == -1:  # 相邻不知道，深度，并取最小
                    ids[cur_node] = min(dfs(next_node,cur_id+1,cur_node),ids[cur_node])
                else: # 相邻有，取最小
                    ids[cur_node] = min(ids[cur_node],ids[next_node])

            # 整理完的最终id == cur_id（上面传进来的）
            # 是环的脑袋
            # 另外不要忘记 排除特殊
            if ids[cur_node] == cur_id and cur_node != 0:
                res.append((par,cur_node))
            return ids[cur_node]
        
        dfs(0,0,-1)
        return res
~~~

